==================================================
FILE: lib/session.ts
==================================================
import { cookies } from "next/headers";

const SESSION_COOKIE_NAME = "paytapper_session";
const SESSION_TTL_SECONDS = 60 * 60 * 24 * 7; // 7 days

export type SessionData = {
  userAuthId: string;
  clientId: string;
};

export async function setSession(session: SessionData): Promise<void> {
  const value = JSON.stringify(session);

  const cookieStore = await cookies();
  cookieStore.set({
    name: SESSION_COOKIE_NAME,
    value,
    httpOnly: true,
    sameSite: "lax",
    secure: true,
    path: "/",
    maxAge: SESSION_TTL_SECONDS,
  });
}

export async function getSession(): Promise<SessionData | null> {
  const cookieStore = await cookies();
  const cookie = cookieStore.get(SESSION_COOKIE_NAME);
  if (!cookie?.value) return null;

  try {
    const parsed = JSON.parse(cookie.value) as SessionData;

    if (
      typeof parsed.userAuthId !== "string" ||
      typeof parsed.clientId !== "string"
    ) {
      return null;
    }

    return parsed;
  } catch {
    return null;
  }
}

export async function clearSession(): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.delete(SESSION_COOKIE_NAME);
}

==================================================
FILE: app/post-auth/page.tsx
==================================================
import { redirect } from "next/navigation";
import { getSession } from "@/lib/session";

export const dynamic = "force-dynamic";

export default async function PostAuthPage() {
  const session = await getSession();

  // IMPORTANT:
  // Do NOT redirect if session is not yet available.
  // This page acts as a stabilization buffer for cookie propagation.
  if (!session) {
    return null;
  }

  redirect(`/client/${session.clientId}/dashboard`);
}

==================================================
FILE: app/register/page.tsx
==================================================
"use client";

import { useState } from "react";

export default function RegisterPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [passwordConfirm, setPasswordConfirm] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError(null);

    if (!email || !password || !passwordConfirm) {
      setError("All fields are required.");
      return;
    }

    if (password !== passwordConfirm) {
      setError("Passwords do not match.");
      return;
    }

    setLoading(true);
    try {
      const r = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password, passwordConfirm }),
      });

      const data = await r.json();

      if (!r.ok) {
        setError(data?.error || "Registration failed");
        return;
      }

      // CRITICAL: go through post-auth to avoid cookie race
      window.location.href = "/post-auth";
    } catch {
      setError("Network error");
    } finally {
      setLoading(false);
    }
  }

  return (
    <main className="min-h-screen bg-black text-white flex items-start justify-center p-6">
      <div className="w-full max-w-md">
        <h1 className="text-3xl font-semibold mb-8">Create your account</h1>

        <form onSubmit={onSubmit} className="space-y-4">
          <div className="space-y-2">
            <label className="text-sm text-gray-300">Email</label>
            <input
              className="w-full rounded-md bg-white text-black px-3 py-2 outline-none"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="you@example.com"
              required
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm text-gray-300">Password</label>
            <input
              className="w-full rounded-md bg-black text-white border border-gray-700 px-3 py-2 outline-none"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="********"
              required
            />
          </div>

          <div className="space-y-2">
            <label className="text-sm text-gray-300">Confirm password</label>
            <input
              className="w-full rounded-md bg-black text-white border border-gray-700 px-3 py-2 outline-none"
              type="password"
              value={passwordConfirm}
              onChange={(e) => setPasswordConfirm(e.target.value)}
              placeholder="********"
              required
            />
          </div>

          {error ? <p className="text-sm text-red-400">{error}</p> : null}

          <button
            className="w-full rounded-md border border-gray-700 px-3 py-2 text-sm font-medium hover:bg-gray-900 disabled:opacity-50"
            type="submit"
            disabled={loading}
          >
            {loading ? "Creating account..." : "Create account"}
          </button>
        </form>
      </div>
    </main>
  );
}

==================================================
FILE: app/login/page.tsx
==================================================
"use client";

export default function LoginPage() {
  return (
    <main className="max-w-md mx-auto p-6 space-y-6">
      <h1 className="text-2xl font-semibold">Log in</h1>

      <p className="text-sm text-gray-700">
        Login is not available in version 1 of Paytapper.
      </p>

      <p className="text-sm text-gray-700">
        The current version focuses on payments, tipping, and Stripe Connect
        onboarding. Authentication will be introduced in a future version.
      </p>

      <button
        className="w-full rounded-md border border-gray-700 px-3 py-2 text-sm font-medium opacity-50 cursor-not-allowed"
        disabled
      >
        Login disabled
      </button>

      <p className="text-sm text-gray-600">
        New here?{" "}
        <span className="underline opacity-50 cursor-not-allowed">
          Registration is currently disabled
        </span>
      </p>
    </main>
  );
}

==================================================
FILE: app/page.tsx
==================================================
import Link from "next/link";

export default function HomePage() {
  return (
    <main className="mx-auto max-w-3xl px-6 py-20 text-center">
      <h1 className="text-4xl font-bold tracking-tight">
        Paytapper
      </h1>

      <p className="mt-6 text-lg text-gray-600">
        Simple QR-based tipping and small payments for guides, drivers and creators.
      </p>

      <div className="mt-10 flex flex-col items-center gap-4">
        <Link
          href="/tip/demo"
          className="rounded-md bg-black px-6 py-3 text-white hover:bg-gray-800"
        >
          Open demo tip page
        </Link>

        <p className="text-sm text-gray-500">
          Client accounts and authentication are coming in v1.1
        </p>
      </div>
    </main>
  );
}

==================================================
FILE: app/client/[clientId]/dashboard/page.tsx
==================================================
export const dynamic = "force-dynamic";

import { redirect } from "next/navigation";
import { getSession } from "@/lib/session";
import { getClientById } from "@/lib/clientStore";
import {
  getPaymentsSummaryByClientId,
  getPaymentsByClientId,
} from "@/lib/paymentStore";
import { stripeMode } from "@/lib/stripe";
import { StartOnboardingButton } from "./start-onboarding-button";
import { OpenStripeDashboardButton } from "./open-stripe-dashboard-button";
import { LogoutButton } from "./logout-button";
import { DownloadPaymentsCsvButton } from "./download-payments-csv-button";

type Params = { clientId: string };

function formatEur(cents: number): string {
  return (cents / 100).toFixed(2);
}

function paymentDateIso(p: { paidAt?: string; createdAt: string }): string {
  return p.paidAt ?? p.createdAt;
}

function getBaseUrl(): string {
  const explicit = process.env.NEXT_PUBLIC_BASE_URL;
  if (explicit && explicit.trim()) return explicit.trim();
  const vercelUrl = process.env.VERCEL_URL;
  if (vercelUrl && vercelUrl.trim()) {
    return vercelUrl.startsWith("http") ? vercelUrl : `https://${vercelUrl}`;
  }
  return "http://localhost";
}

function isLocalhost(url: string): boolean {
  return url.includes("localhost") || url.includes("127.0.0.1");
}

export default async function DashboardPage({
  params,
}: {
  params: Promise<Params>;
}) {
  const { clientId } = await params;

  const session = await getSession();

  // v1 rule: dashboard never redirects to /login
  // all auth resolution must go through /post-auth
  if (!session || session.clientId !== clientId) {
    redirect("/post-auth");
  }

  const client = await getClientById(clientId);
  if (!client) redirect("/post-auth");

  const summary = await getPaymentsSummaryByClientId(clientId);
  const payments = await getPaymentsByClientId(clientId);

  const recentPayments = payments
    .slice()
    .sort((a, b) => paymentDateIso(b).localeCompare(paymentDateIso(a)))
    .slice(0, 5);

  const isLive = stripeMode === "live";
  const baseUrl = getBaseUrl();
  const showTestWarning = stripeMode === "test" && !isLocalhost(baseUrl);

  return (
    <main className="max-w-xl mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <h1 className="text-2xl font-semibold">Dashboard</h1>
          <span
            className={`rounded-full px-2 py-0.5 text-xs font-medium ${
              isLive ? "bg-green-100 text-green-700" : "bg-yellow-100 text-yellow-700"
            }`}
          >
            {isLive ? "LIVE" : "TEST"}
          </span>
        </div>
        <LogoutButton />
      </div>

      {showTestWarning && (
        <div className="rounded-lg border border-yellow-300 bg-yellow-50 p-3 text-sm text-yellow-800">
          <strong>Test mode:</strong> You are running Paytapper in Stripe TEST mode
          on a non-localhost URL. Do not share this link with real users.
        </div>
      )}

      <section className="border rounded-lg p-4 space-y-2">
        <h2 className="font-semibold">Client info</h2>
        <p><strong>Client ID:</strong> {clientId}</p>
        {client.displayName && <p><strong>Name:</strong> {client.displayName}</p>}
        {client.email && <p><strong>Email:</strong> {client.email}</p>}
      </section>

      <section className="border rounded-lg p-4 space-y-3">
        <h2 className="font-semibold">Stripe</h2>
        <StartOnboardingButton clientId={clientId} />
        {client.stripe?.accountId && <OpenStripeDashboardButton />}
      </section>

      <section className="border rounded-lg p-4 space-y-3">
        <h2 className="font-semibold">Payments</h2>
        <p><strong>Total received:</strong> {formatEur(summary.totalNetCents)} â‚¬</p>
        <DownloadPaymentsCsvButton clientId={clientId} />
      </section>
    </main>
  );
}

==================================================
FILE: app/api/auth/register/route.ts
==================================================
import { NextRequest, NextResponse } from "next/server";
import { randomUUID } from "crypto";
import bcrypt from "bcryptjs";

import { createUser, getUserByEmail } from "@/lib/userStore";
import { createClient } from "@/lib/clientStore";
import { setSession } from "@/lib/session";
import { User } from "@/lib/types";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const email = String(body.email ?? "").trim().toLowerCase();
    const password = String(body.password ?? "");
    const passwordConfirm = String(body.passwordConfirm ?? "");

    if (!email || !password || !passwordConfirm) {
      return NextResponse.json({ error: "Missing fields" }, { status: 400 });
    }

    if (password.length < 8) {
      return NextResponse.json({ error: "Password too short" }, { status: 400 });
    }

    if (password !== passwordConfirm) {
      return NextResponse.json({ error: "Passwords do not match" }, { status: 400 });
    }

    const existing = await getUserByEmail(email);
    if (existing) {
      return NextResponse.json({ error: "Email already registered" }, { status: 409 });
    }

    const passwordHash = await bcrypt.hash(password, 12);

    const user: User = {
      id: randomUUID(),
      email,
      passwordHash,
      authProvider: "local",
      emailVerified: false,
      createdAt: new Date().toISOString(),
    };

    await createUser(user);

    const client = await createClient({
      displayName: email.split("@")[0],
      email,
      payoutMode: "direct",
      ownerUserId: user.id,
    });

    await setSession({
      userAuthId: user.id,
      clientId: client.id,
    });

    return NextResponse.json({ clientId: client.id }, { status: 201 });
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

==================================================
FILE: app/api/auth/login/route.ts
==================================================
import { NextRequest, NextResponse } from "next/server";
import bcrypt from "bcryptjs";

import { getUserByEmail } from "@/lib/userStore";
import { getClientByOwnerUserId } from "@/lib/clientStore";
import { setSession } from "@/lib/session";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const email = String(body.email ?? "").trim().toLowerCase();
    const password = String(body.password ?? "");

    if (!email || !password) {
      return NextResponse.json({ error: "Missing fields" }, { status: 400 });
    }

    const user = await getUserByEmail(email);
    if (!user || user.authProvider !== "local" || !user.passwordHash) {
      return NextResponse.json({ error: "Invalid credentials" }, { status: 401 });
    }

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) {
      return NextResponse.json({ error: "Invalid credentials" }, { status: 401 });
    }

    const client = await getClientByOwnerUserId(user.id);
    if (!client) {
      return NextResponse.json({ error: "Client not found" }, { status: 500 });
    }

    await setSession({
      userAuthId: user.id,
      clientId: client.id,
    });

    return NextResponse.json({ clientId: client.id }, { status: 200 });
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

==================================================
FILE: app/api/auth/logout/route.ts
==================================================
import { NextResponse } from "next/server";
import { clearSession } from "@/lib/session";

export async function POST() {
  await clearSession();
  return NextResponse.json({ ok: true });
}

==================================================
FILE: app/api/clients/route.ts
==================================================
import { NextRequest, NextResponse } from "next/server";

import { getSession } from "@/lib/session";
import { createClient } from "@/lib/clientStore";

export async function POST(req: NextRequest) {
  try {
    const session = await getSession();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();

    const displayName = String(body.displayName ?? "").trim();
    const email =
      typeof body.email === "string" && body.email.trim()
        ? body.email.trim().toLowerCase()
        : undefined;

    const payoutMode =
      body.payoutMode === "platform" ? "platform" : "direct";

    if (!displayName) {
      return NextResponse.json(
        { error: "Missing displayName" },
        { status: 400 }
      );
    }

    const client = await createClient({
      displayName,
      email,
      payoutMode,
      ownerUserId: session.userAuthId,
    });

    return NextResponse.json(
      {
        clientId: client.id,
      },
      { status: 201 }
    );
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Unknown error";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({ error: "Method Not Allowed" }, { status: 405 });
}

